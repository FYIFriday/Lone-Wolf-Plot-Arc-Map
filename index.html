<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>arc_map.pdf Viewer</title>

</head>
  <!-- PDF.js (UMD build) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #111;
      color: #eee;
    }

    #toolbar {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 10;
      display: flex;
      gap: 8px;
      padding: 6px 8px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(6px);
      border-radius: 8px;
      align-items: center;
      font-size: 13px;
      user-select: none;
    }

    #toolbar button {
      border: none;
      padding: 4px 8px;
      border-radius: 4px;
      background: #222;
      color: #eee;
      cursor: pointer;
      font-size: 12px;
    }

    #toolbar button:hover {
      background: #333;
    }

    #scaleDisplay {
      min-width: 70px;
      text-align: right;
      opacity: 0.9;
    }

    #viewer {
      position: absolute;
      inset: 0;
      overflow: scroll;
      cursor: grab;
      background: #111;
    }

    #viewer.dragging {
      cursor: grabbing;
    }

    #pdf-canvas {
      display: block;
      margin: auto;
      image-rendering: crisp-edges;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="zoomOut">-</button>
    <button id="zoomIn">+</button>
    <button id="zoomReset">Reset</button>
    <span id="scaleDisplay">100%</span>
    <span style="opacity:0.7;">(Two-finger scroll = pan, pinch with âŒ˜/Ctrl = zoom)</span>
  </div>

  <div id="viewer">
    <canvas id="pdf-canvas"></canvas>
  </div>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const PDF_URL = 'arc_map.pdf';

      let pdfDoc = null;
      let pageNum = 1;

      // Actual render scale (what the PDF is drawn at)
      let scale = 1.0;

      // Limits
      const MIN_SCALE = 0.1;
      const MAX_SCALE = 32;
      const BUTTON_ZOOM_STEP = 0.25;

      const viewer = document.getElementById('viewer');
      const canvas = document.getElementById('pdf-canvas');
      const ctx = canvas.getContext('2d');
      const zoomInBtn = document.getElementById('zoomIn');
      const zoomOutBtn = document.getElementById('zoomOut');
      const zoomResetBtn = document.getElementById('zoomReset');
      const scaleDisplay = document.getElementById('scaleDisplay');

      let pdfReady = false;

      // Render queue flags so we don't spam renders
      let isRendering = false;
      let zoomFrameRequested = false;
      let lastZoomScale = scale;
      let lastZoomX = 0;
      let lastZoomY = 0;

      // Configure PDF.js worker
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

      // Load the PDF
      pdfjsLib.getDocument(PDF_URL).promise.then((pdf) => {
        pdfDoc = pdf;
        pdfReady = true;
        renderPage(); // initial render
      }).catch((error) => {
        console.error('Error loading PDF:', error);
        scaleDisplay.textContent = 'Error loading PDF';
      });

      function renderPage() {
        if (!pdfReady || !pdfDoc) return;
        if (isRendering) return; // let queued zoom handle updates

        isRendering = true;

        pdfDoc.getPage(pageNum).then((page) => {
          const viewport = page.getViewport({ scale });

          canvas.width = viewport.width;
          canvas.height = viewport.height;

          const renderContext = {
            canvasContext: ctx,
            viewport: viewport
          };

          const renderTask = page.render(renderContext);
          return renderTask.promise;
        }).then(() => {
          isRendering = false;
          updateScaleDisplay();

          // If something queued another zoom during render, handle it now
          if (zoomFrameRequested) {
            zoomFrameRequested = false;
            setScale(lastZoomScale, lastZoomX, lastZoomY);
          }
        }).catch((err) => {
          isRendering = false;
          console.error('Render error:', err);
        });
      }

      function updateScaleDisplay() {
        scaleDisplay.textContent = Math.round(scale * 100) + '%';
      }

      function setScale(newScale, centerX, centerY) {
        if (!pdfReady) return;

        // Clamp
        if (newScale < MIN_SCALE) newScale = MIN_SCALE;
        if (newScale > MAX_SCALE) newScale = MAX_SCALE;

        // Ignore microscopic changes to avoid stutter
        if (Math.abs(newScale - scale) < scale * 0.02) return;

        const rect = viewer.getBoundingClientRect();

        // Current scroll position mapped into PDF coords
        const vx = (centerX - rect.left + viewer.scrollLeft) / scale;
        const vy = (centerY - rect.top + viewer.scrollTop) / scale;

        scale = newScale;

        renderPage();

        // After render, recenter so the point under cursor stays under cursor
        requestAnimationFrame(() => {
          const newScrollLeft = vx * scale - (centerX - rect.left);
          const newScrollTop = vy * scale - (centerY - rect.top);

          viewer.scrollLeft = newScrollLeft;
          viewer.scrollTop = newScrollTop;
        });
      }

      // Smooth-ish zoom scheduler for wheel/pinch events
      function smartZoom(targetScale, cx, cy) {
        if (!pdfReady) return;

        // Clamp
        if (targetScale < MIN_SCALE) targetScale = MIN_SCALE;
        if (targetScale > MAX_SCALE) targetScale = MAX_SCALE;

        // Coalesce rapid events into one render per frame
        lastZoomScale = targetScale;
        lastZoomX = cx;
        lastZoomY = cy;

        if (!zoomFrameRequested && !isRendering) {
          zoomFrameRequested = true;
          requestAnimationFrame(() => {
            zoomFrameRequested = false;
            setScale(lastZoomScale, lastZoomX, lastZoomY);
          });
        }
      }

      // Toolbar zoom (uses fixed steps)
      zoomInBtn.addEventListener('click', () => {
        const cx = viewer.clientWidth / 2;
        const cy = viewer.clientHeight / 2;
        smartZoom(scale + BUTTON_ZOOM_STEP, cx, cy);
      });

      zoomOutBtn.addEventListener('click', () => {
        const cx = viewer.clientWidth / 2;
        const cy = viewer.clientHeight / 2;
        smartZoom(scale - BUTTON_ZOOM_STEP, cx, cy);
      });

      zoomResetBtn.addEventListener('click', () => {
        const cx = viewer.clientWidth / 2;
        const cy = viewer.clientHeight / 2;
        smartZoom(1.0, cx, cy);
      });

      // Ctrl/Cmd + wheel / pinch zoom (Mac trackpad friendly)
      viewer.addEventListener('wheel', (e) => {
        if (!pdfReady) return;

        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();

          // Trackpad pinch usually gives small continuous deltaY.
          // Use an exponential factor for smooth zoom.
          const zoomFactor = Math.exp(-e.deltaY * 0.002);
          const targetScale = scale * zoomFactor;

          smartZoom(targetScale, e.clientX, e.clientY);
        }
        // plain wheel = scroll/pan, let browser handle it
      }, { passive: false });

      // Click-and-drag panning
      let isDragging = false;
      let startX, startY, startScrollLeft, startScrollTop;

      viewer.addEventListener('mousedown', (e) => {
        isDragging = true;
        viewer.classList.add('dragging');
        startX = e.clientX;
        startY = e.clientY;
        startScrollLeft = viewer.scrollLeft;
        startScrollTop = viewer.scrollTop;
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
        viewer.classList.remove('dragging');
      });

      viewer.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        viewer.scrollLeft = startScrollLeft - dx;
        viewer.scrollTop = startScrollTop - dy;
      });
    });
  </script>
</body>
</html>
</body>
</html>